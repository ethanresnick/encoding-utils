import stringify from "safe-stable-stringify";
import type { GetTagMetadata, Tagged, UnwrapTagged } from "type-fest";

/**
 * This function accepts any JS string and encodes it in base64, using a UTF8
 * representation of the string to derive the underlying binary data.
 */
export function b64Encode<T extends string>(it: T) {
  return Buffer.from(it, "utf-8").toString("base64") as B64Of<T>;
}

/**
 * Base64 encodes arbitrary binary data in an array buffer.
 */
export function b64EncodeArrayBuffer<T extends ArrayBuffer>(it: T) {
  return Buffer.from(it).toString("base64") as unknown as B64Of<T>;
}

/**
 * This function accepts any b64 encoded string, as generated by
 *  {@link b64Encode}, and returns the original JS string that was encoded.
 */
export function b64Decode<T extends B64Of<string>>(it: T) {
  return Buffer.from(it, "base64").toString("utf-8") as UnwrapTagged<T>;
}

export function b64UrlEncode<T extends string>(it: T) {
  return b64Encode(it).replaceAll("+", "-").replaceAll("/", "_") as B64UrlOf<T>;
}

export function b64UrlDecode<T extends B64UrlOf<string>>(it: T) {
  const b64String = it.replaceAll("-", "+").replaceAll("_", "/") as B64Of<
    UnwrapTagged<T>
  >;

  return b64Decode(b64String);
}

export type B64Of<T> = Tagged<T, "B64">;
export type B64UrlOf<T> = Tagged<T, "B64Url">;

/**
 * This function encodes a string in a way that allows it to be used as data in
 * an RFC 3986 URI. It extends the built-in `encodeURIComponent` to also percent
 * encode some extra characters that were only reserved (in certain contexts)
 * starting in RFC 3986. This encodes everything except A–Z a–z 0–9 - _ . ~,
 * which is the "unreserved" set in RFC 3986.
 */
export function encodeURIComponentRFC3986(
  str: `${string}${AlphaNumeric}`
): `${string}${AlphaNumeric}`;
export function encodeURIComponentRFC3986(str: string): string;
export function encodeURIComponentRFC3986(str: string) {
  return encodeURIComponent(str).replace(
    /[!'()*]/g,
    (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`
  );
}

export type UppercaseAlpha =
  | "A"
  | "B"
  | "C"
  | "D"
  | "E"
  | "F"
  | "G"
  | "H"
  | "I"
  | "J"
  | "K"
  | "L"
  | "M"
  | "N"
  | "O"
  | "P"
  | "Q"
  | "R"
  | "S"
  | "T"
  | "U"
  | "V"
  | "W"
  | "X"
  | "Y"
  | "Z";

export type Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
export type AlphaNumeric = UppercaseAlpha | Lowercase<UppercaseAlpha> | Digit;

/**
 * Converts a value to JSON, while preserving its type for future inspection.
 *
 * Sometimes, we need to stringify a value (e.g., to use the string as a key),
 * but we'd still like to Typescript to track the original type that we
 * stringified, so that we can have type checking on the data we'll get back
 * if/when we JSON.parse the string later. That's what this `jsonStringify`
 * helper function does. See {@link jsonParse}.
 *
 * This string is also "stable", i.e., key insertion order in serialized objects
 * _does not_ affect the final string, which is good for making cache keys.
 *
 * NB: technically, this should return a JsonOf<Jsonify<T>>, but we don't do
 * that for now because using Jsonify almost always runs up against TS stack
 * limits.
 *
 * @param it The value to stringify.
 */
export function jsonStringify<T>(it: T) {
  return stringify(it) as JsonOf<T>;
}

/**
 * Identical to {@link jsonStringify}, except that it does not normalize the
 * order of object keys in the final, returned string. Therefore, e.g.,
 * `{ a: 0, b: 0 }` and `{ b: 0, a: 0 }` will produce different strings. This is
 * usually not what you want -- it prevents the resulting string from being used
 * reliably as a cache key, e.g. -- but may give slightly better performance.
 */
export function jsonStringifyUnstable<T>(it: T) {
  // eslint-disable-next-line no-restricted-syntax
  return JSON.stringify(it) as JsonOf<T>;
}

/**
 * Parses the JSON, and returns its original type, for JSON generated by
 * {@link jsonStringify}.
 */
export function jsonParse<T extends JsonOf<unknown>>(it: T) {
  return JSON.parse(it) as GetTagMetadata<T, "JSON">;
}

export type JsonOf<T> = Tagged<string, "JSON", T>;
